# .github/workflows/pr-link-submodule.yml
name: Link and Validate Submodule PR

on:
  pull_request:
    types: [opened, synchronize]
    branches:
      - main
      - master
      - develop  # Add your target branches here

jobs:
  # Job 1: Checkout once and discover all submodules
  discover-submodules:
    name: Discover Submodules
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.submodule.outputs.matrix }}
      has-submodules: ${{ steps.submodule.outputs.has-submodules }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Only checkout the main repo, not submodules yet
          submodules: true #maybe false idk
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get changed submodules
        id: submodule
        run: |
          set -x  
          # Figure out the base ref (for PRs, use the PR base; otherwise fallback to main)
          if [[ -n "${{ github.event.pull_request.base.sha }}" ]]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
          else
            BASE_SHA="origin/main"
          fi

          echo "Comparing against base: $BASE_SHA"

          # Get list of actual submodules from .gitmodules
          ACTUAL_SUBMODULES=$(git config --file .gitmodules --get-regexp "submodule\..*\.path" | awk '{print $2}' || true)
          
          if [[ -z "$ACTUAL_SUBMODULES" ]]; then
            echo "No submodules found in .gitmodules"
            echo "has-submodules=false" >> $GITHUB_OUTPUT
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get all changed files
          ALL_CHANGED_FILES=$(git diff --name-only $BASE_SHA HEAD || true)
          
          # Filter to only include actual submodules that have changes
          CHANGED_SUBMODULES=""
          for submodule_path in $ACTUAL_SUBMODULES; do
            if echo "$ALL_CHANGED_FILES" | grep -q "^$submodule_path$"; then
              CHANGED_SUBMODULES="$CHANGED_SUBMODULES $submodule_path"
            fi
          done

          if [[ -z "$CHANGED_SUBMODULES" ]]; then
            echo "No submodule changes detected"
            echo "has-submodules=false" >> $GITHUB_OUTPUT
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            exit 0
          fi

          MATRIX_JSON="{\"include\":["
          FIRST=true
          COUNT=0

          for SUBMODULE_PATH in $CHANGED_SUBMODULES; do
            echo "Processing changed submodule: $SUBMODULE_PATH"

            # Extract name from .gitmodules
            submodule_name=$(git config --file .gitmodules --get-regexp "submodule\..*\.path" | \
                            awk -v p="$SUBMODULE_PATH" '$2==p {print $1}' | sed 's/submodule\.//; s/\.path//')

            SUBMODULE_URL=$(git config --file .gitmodules --get "submodule.$submodule_name.url")

            if [[ -z "$SUBMODULE_URL" ]]; then
              echo "  Skipping $SUBMODULE_PATH (no URL)"
              continue
            fi

            if [[ $SUBMODULE_URL == git@github.com:* ]]; then
              SUBMODULE_REPO=$(echo $SUBMODULE_URL | sed 's/git@github.com://' | sed 's/.git$//')
            elif [[ $SUBMODULE_URL == https://github.com/* ]]; then
              SUBMODULE_REPO=$(echo $SUBMODULE_URL | sed 's/https:\/\/github.com\///' | sed 's/.git$//')
            else
              echo "  Skipping non-GitHub submodule: $SUBMODULE_URL"
              continue
            fi

            IFS='/' read -r owner repo <<< "$SUBMODULE_REPO"

            if [[ $FIRST == true ]]; then
              FIRST=false
            else
              MATRIX_JSON="$MATRIX_JSON,"
            fi

            MATRIX_JSON="$MATRIX_JSON{\"path\":\"$SUBMODULE_PATH\",\"repo\":\"$SUBMODULE_REPO\",\"owner\":\"$owner\",\"repo_name\":\"$repo\",\"name\":\"$submodule_name\"}"
            COUNT=$((COUNT + 1))
          done

          MATRIX_JSON="$MATRIX_JSON]}"
          echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT

          if [[ $COUNT -gt 0 ]]; then
            echo "has-submodules=true" >> $GITHUB_OUTPUT
          else
            echo "has-submodules=false" >> $GITHUB_OUTPUT
          fi

          echo "Found $COUNT changed submodules"
          echo "Matrix JSON: $MATRIX_JSON"


  # Job 2: Process each submodule in parallel (PR linking, etc.)      
  link-and-validate:
    name: Link and Validate
    needs: discover-submodules
    if: needs.discover-submodules.outputs.has-submodules == 'true' && startsWith(github.head_ref, 'users/')

    runs-on: ubuntu-latest
    continue-on-error: true
    permissions:
      contents: write
      pull-requests: write
      issues: write
      checks: write
      statuses: write

    strategy:
      # Process up to 5 submodules in parallel (adjust as needed)
      fail-fast: false
      max-parallel: 5
      matrix: ${{ fromJson(needs.discover-submodules.outputs.matrix) }}
    
    steps:
      - name: Process submodule - ${{ matrix.owner }}/${{ matrix.repo_name }}
        run: |
          echo "Processing submodule: ${{ matrix.owner }}/${{ matrix.repo_name }}"
          echo "Path: ${{ matrix.path }}"
          echo "Full repo: ${{ matrix.repo }}"
          
      # This step doesn't need to checkout the main repo again!
      # It only works with the submodule repository via API calls

      - name: Extract ticket number
        id: extract
        run: |
          BRANCH_NAME="${{ github.head_ref }}"
          TICKET_NUM=$(echo "$BRANCH_NAME" | sed 's/users\///')
          echo "ticket_num=$TICKET_NUM" >> $GITHUB_OUTPUT
          echo "Branch: $BRANCH_NAME, Ticket: $TICKET_NUM"
      
      - name: Check for submodule PR
        id: check_pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const branchName = 'users/${{ steps.extract.outputs.ticket_num }}';
            const owner = '${{ matrix.owner }}';
            const repo = '${{ matrix.repo_name }}';
            const path = '${{ matrix.path }}';
            // Search for PR with matching branch
            const { data: prs } = await github.rest.pulls.list({
              owner: owner,
              repo: repo,
              state: 'open',
              head: `${owner}:${branchName}`
            });
            
            if (prs.length === 0) {
              core.setOutput('found', 'false');
              core.setOutput('pr_url', '');
              core.setOutput('pr_number', '');
              return;
            }
            
            const pr = prs[0];
            core.setOutput('found', 'true');
            core.setOutput('pr_url', pr.html_url);
            core.setOutput('pr_number', pr.number.toString());
            core.setOutput('pr_state', pr.state);

      - name: Create check run for submodule PR status
        id: antman
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const found = '${{ steps.check_pr.outputs.found }}' === 'true';
            const prUrl = '${{ steps.check_pr.outputs.pr_url }}';
            const submodulePrUrl = '${{ steps.check_pr.outputs.pr_url }}';
            core.setOutput('is_approved', 'false');
            
            // Check if submodules were updated in this PR
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            // Get list of submodules from .gitmodules to check against
            let submodulePaths = [];
            try {
              const { data: gitmodules } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: '.gitmodules',
                ref: context.payload.pull_request.base.sha
              });
              
              const content = Buffer.from(gitmodules.content, 'base64').toString();
              const pathMatches = content.match(/path = (.+)/g);
              if (pathMatches) {
                submodulePaths = pathMatches.map(match => match.replace('path = ', '').trim());
              }
            } catch (error) {
              console.log('No .gitmodules found or error reading it:', error.message);
            }
            
            const submodule_updated = files.some(file => {
              // Check if .gitmodules itself was modified
              if (file.filename === '.gitmodules') {
                return true;
              }
              
              // Check if any known submodule paths were modified
              return submodulePaths.some(submodulePath => {
                return file.filename === submodulePath || file.filename.startsWith(submodulePath + '/');
              });
            });
            
            console.log(`Submodule updated: ${submodule_updated}`);

            let status, conclusion, title, summary;
            
            if (!found) {
              // search to see if submodule was updated to begin with
              if (submodule_updated) {
                status = 'completed';
                conclusion = 'failure';
                title = 'Submodule PR Not Found';
                summary = `Submodule was updated but no open PR found in submodule repository for branch users/${{ steps.extract.outputs.ticket_num }}`;
                console.error("❌ Failed");
                process.exit(1);
              } else {
                // No submodule updated, skip this check entirely
                status = 'completed';
                conclusion = 'success';
                title = 'Submodule Check Skipped';
                //summary = `No submodules were updated in this PR, skipping submodule PR check. Submodule updated: ${submodule_updated}`;
                //console.error("✅ Skipping submodule");
                process.exit(0);
              }
            } else {
              // PR found - now check if it's open and approved
              
              // Extract PR number and repo info from the PR URL
              // Assuming prUrl format: https://github.com/owner/repo/pull/123
              const urlParts = prUrl.match(/github\.com\/([^\/]+)\/([^\/]+)\/pull\/(\d+)/);
              if (!urlParts) {
                status = 'completed';
                conclusion = 'failure';
                title = 'Invalid PR URL';
                summary = `Could not parse submodule PR URL: ${prUrl}`;
              } else {
                const [, submoduleOwner, submoduleRepo, prNumber] = urlParts;
                
                try {
                  // Get PR details
                  const { data: pr } = await github.rest.pulls.get({
                    owner: submoduleOwner,
                    repo: submoduleRepo,
                    pull_number: parseInt(prNumber)
                  });
                  
                  console.log(`PR State: ${pr.state}`);
                  console.log(`PR Mergeable State: ${pr.mergeable_state}`);
                  
                  // Check if PR is open
                  if (pr.state !== 'open') {
                    status = 'completed';
                    conclusion = 'failure';
                    title = 'Submodule PR Closed';
                    summary = `Linked submodule PR is ${pr.state}: ${prUrl}`;
                  } else {
                    // PR is open, now check approval status
                    const { data: reviews } = await github.rest.pulls.listReviews({
                      owner: submoduleOwner,
                      repo: submoduleRepo,
                      pull_number: parseInt(prNumber)
                    });
                    
                    // Get latest review from each reviewer
                    const latestReviews = {};
                    reviews.forEach(review => {
                      if (review.state !== 'COMMENTED') { // Only consider APPROVED, CHANGES_REQUESTED, DISMISSED
                        latestReviews[review.user.login] = review;
                      }
                    });
                    
                    // Check if there are any approvals and no blocking change requests
                    const approvals = Object.values(latestReviews).filter(review => review.state === 'APPROVED');
                    const changeRequests = Object.values(latestReviews).filter(review => review.state === 'CHANGES_REQUESTED');
                    
                    console.log(`Approvals: ${approvals.length}, Change Requests: ${changeRequests.length}`);
                    
                    // Check if PR is ready to merge
                    const isApproved = approvals.length > 0 && changeRequests.length === 0;
                    
                    if (isApproved) {
                      core.setOutput('is_approved', 'true');
                      status = 'completed';
                      conclusion = 'success';
                      title = 'Submodule PR Approved';
                      summary = `Submodule PR is open and approved: ${prUrl}\n\nApprovals: ${approvals.length}\nReady for coordinated merge.`;
                    } else {
                      status = 'in_progress';
                      conclusion = undefined;
                      title = 'Submodule PR Awaiting Approval';
                      summary = `Linked to submodule PR: ${prUrl}\n\nStatus: Open but not yet approved\nApprovals: ${approvals.length}\nChange Requests: ${changeRequests.length}\n\nWaiting for approval before allowing merge.`;
                    }
                  }
                } catch (error) {
                  console.error('Error checking PR status:', error);
                  status = 'completed';
                  conclusion = 'failure';
                  title = 'Error Checking Submodule PR';
                  summary = `Failed to check status of submodule PR: ${prUrl}\nError: ${error.message}`;
                }
              }
            }
      
      - name: Add PR label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const found = '${{ steps.check_pr.outputs.found }}' === 'true';
            const label = found ? 'submodule-linked' : 'submodule-pending';
            const isApproved = '${{ steps.antman.outputs.is_approved }}' === 'true';
            console.log(`Label: ${label}, Submodule PR Status: ${isApproved}`);
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: [label]
            });

            // Update labels
            if(isApproved) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['ready-to-merge']
              });  
            };

      - name: Add comment with submodule PR link
        if: steps.check_pr.outputs.found == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            const submodulePrUrl = '${{ steps.check_pr.outputs.pr_url }}';
            const submoduleRepo = '${{ matrix.repo_name }}';
            const isApproved = '${{ steps.antman.outputs.is_approved }}' === 'true';
            console.log(`Submodule PR Status: ${isApproved}`);
            let approval_comment;
            if (isApproved) {
              approval_comment = "✅ submodule PR approved!";
            } else {
              approval_comment = "⏳ Waiting for submodule PR to be approved";
            }
            const comment = `🔗 Linked Submodule PR: [\`${submoduleRepo}\`](${submodulePrUrl})\nStatus = ${approval_comment}`;
            
            // Check if we already commented
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            console.log("number of comments: " + comments.length);
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes(`🔗 Linked Submodule PR: [\`${submoduleRepo}\`]`)
            );
            
            if (botComment) {
              console.log('Comment already exists');
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              console.log('Comment does not exist');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: comment
              });
            }
      - name: Status Report
        if: steps.check_pr.outputs.found == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const isFound = '${{ steps.check_pr.outputs.found }}' === 'true';
            const isApproved = '${{ steps.antman.outputs.is_approved }}' === 'true';
            console.log(isFound);
            console.log(isApproved);
            if (isFound === true && isApproved === true) {
              console.log("✅ Success");
              process.exit(0);
            } else {
              console.error("❌ Failed");
              process.exit(1);
            }


  #Job 3: Check Submodule Pointers
  check-submodule-pointers:
    runs-on: ubuntu-latest
    name: Validate Submodule Pointers
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: false  # Don't initialize submodules yet
        fetch-depth: 0     # Get full history
        
    - name: Check submodule pointers
      id: check-pointers
      run: |
        #!/bin/bash
        set -e
        
        echo "Checking submodule pointers..."
        
        # Get list of submodules
        if [ ! -f .gitmodules ]; then
          echo "No .gitmodules file found - no submodules to check"
          exit 0
        fi
        
        # Parse .gitmodules to get submodule info
        submodules=$(git config --file .gitmodules --get-regexp path | awk '{print $2}')
        
        if [ -z "$submodules" ]; then
          echo "No submodules found in .gitmodules"
          exit 0
        fi
        
        exit_code=0
        
        for submodule_path in $submodules; do
          echo "Checking submodule: $submodule_path"
          
          # Get the submodule URL and current commit SHA
          submodule_url=$(git config --file .gitmodules --get submodule.$submodule_path.url)
          current_sha=$(git ls-tree HEAD $submodule_path | awk '{print $3}')
          
          if [ -z "$current_sha" ]; then
            echo "❌ Could not find SHA for submodule $submodule_path"
            exit_code=1
            continue
          fi
          
          echo "  Current SHA: $current_sha"
          echo "  URL: $submodule_url"
          
          # Clone the submodule repository to a temp directory
          temp_dir=$(mktemp -d)
          echo "  Cloning submodule to check branches..."
          
          if ! git clone "$submodule_url" "$temp_dir" --quiet; then
            echo "❌ Failed to clone submodule repository: $submodule_url"
            exit_code=1
            continue
          fi
          
          cd "$temp_dir"
          
          # Fetch all branches
          git fetch origin --quiet
          
          # Check if the SHA exists on main branch
          if git merge-base --is-ancestor "$current_sha" origin/main 2>/dev/null; then
            echo "✅ SHA $current_sha is reachable from main branch"
          else
            echo "❌ SHA $current_sha is NOT reachable from main branch"
            echo "  This commit may be on a feature branch only"
            
            # Show which branches contain this commit for debugging
            branches_with_commit=$(git branch -r --contains "$current_sha" 2>/dev/null | grep -v "HEAD" | sed 's/origin\///' | tr '\n' ' ' || echo "none")
            echo "  Branches containing this commit: $branches_with_commit"
            
            exit_code=1
          fi
          
          # Cleanup
          cd - > /dev/null
          rm -rf "$temp_dir"
          echo ""
        done
        
        if [ $exit_code -eq 0 ]; then
          echo "🎉 All submodule pointers are valid (pointing to commits on main branch)"
        else
          echo "💥 One or more submodule pointers are invalid"
          echo ""
          echo "To fix this issue:"
          echo "1. Update the submodule to point to a commit that exists on the main branch"
          echo "2. Or merge the feature branch containing the commit into main first"
          echo ""
          echo "Commands to update submodule:"
          echo "  cd <submodule-path>"
          echo "  git checkout main"
          echo "  git pull origin main"
          echo "  cd .."
          echo "  git add <submodule-path>"
          echo "  git commit -m 'Update submodule to latest main'"
        fi
        
        exit $exit_code
        
    - name: Report status
      if: always()
      run: |
        if [ ${{ steps.check-pointers.outcome }} == 'success' ]; then
          echo "✅ Submodule pointer check: PASSED"
        else
          echo "❌ Submodule pointer check: FAILED"
        fi

  # Job 4: Collect results (optional)
  collect-results:
    needs: [discover-submodules, link-and-validate]
    if: always() && needs.discover-submodules.outputs.has-submodules == 'true'
    runs-on: ubuntu-latest
    steps:
      
      - name: Submodules PR Status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const results = '${{ needs.link-and-validate.result }}' === 'true';
            console.log("needs.link-and-validate.result =");
            console.log(results);
            const title = "title";
            const summary = "summary";
            const status = 'completed';
            const conclusion = 'failure';

            const checkRun = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'Submodule PR Status',
              head_sha: context.payload.pull_request.head.sha,
              status: status,
              output: {
                title: title,
                summary: summary
              }
            };
            
            if (conclusion) {
              checkRun.conclusion = conclusion;
            }
            
            await github.rest.checks.create(checkRun);