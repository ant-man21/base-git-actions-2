# .github/workflows/pr-link-submodule.yml
name: Link and Validate Submodule PR

on:
  pull_request:
    types: [opened, synchronize]
    branches:
      - main
      - master
      - develop  # Add your target branches here

jobs:
  # Job 1: Checkout once and discover all submodules
  discover-submodules:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.submodule.outputs.matrix }}
      has-submodules: ${{ steps.submodule.outputs.has-submodules }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Only checkout the main repo, not submodules yet
          submodules: true #maybe false idk
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get changed submodules
        id: submodule
        run: |
          # Figure out the base ref (for PRs, use the PR base; otherwise fallback to main)
          if [[ -n "${{ github.event.pull_request.base.sha }}" ]]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
          else
            BASE_SHA="origin/main"
          fi

          echo "Comparing against base: $BASE_SHA"

          # Collect changed submodules (pointer SHA changes only)
          CHANGED_SUBMODULES=$(git diff --name-only $BASE_SHA HEAD | grep -E '^[^/]+$' || true)

          if [[ -z "$CHANGED_SUBMODULES" ]]; then
            echo "No submodule changes detected"
            echo "has-submodules=false" >> $GITHUB_OUTPUT
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            exit 0
          fi

          MATRIX_JSON="{\"include\":["
          FIRST=true
          COUNT=0

          for SUBMODULE_PATH in $CHANGED_SUBMODULES; do
            echo "Processing changed submodule: $SUBMODULE_PATH"

            # Extract name from .gitmodules
            submodule_name=$(git config --file .gitmodules --get-regexp "submodule\..*\.path" | \
                            awk -v p="$SUBMODULE_PATH" '$2==p {print $1}' | sed 's/submodule\.//; s/\.path//')

            SUBMODULE_URL=$(git config --file .gitmodules --get "submodule.$submodule_name.url")

            if [[ -z "$SUBMODULE_URL" ]]; then
              echo "  Skipping $SUBMODULE_PATH (no URL)"
              continue
            fi

            if [[ $SUBMODULE_URL == git@github.com:* ]]; then
              SUBMODULE_REPO=$(echo $SUBMODULE_URL | sed 's/git@github.com://' | sed 's/.git$//')
            elif [[ $SUBMODULE_URL == https://github.com/* ]]; then
              SUBMODULE_REPO=$(echo $SUBMODULE_URL | sed 's/https:\/\/github.com\///' | sed 's/.git$//')
            else
              echo "  Skipping non-GitHub submodule: $SUBMODULE_URL"
              continue
            fi

            IFS='/' read -r owner repo <<< "$SUBMODULE_REPO"

            if [[ $FIRST == true ]]; then
              FIRST=false
            else
              MATRIX_JSON="$MATRIX_JSON,"
            fi

            MATRIX_JSON="$MATRIX_JSON{\"path\":\"$SUBMODULE_PATH\",\"repo\":\"$SUBMODULE_REPO\",\"owner\":\"$owner\",\"repo_name\":\"$repo\",\"name\":\"$submodule_name\"}"
            COUNT=$((COUNT + 1))
          done

          MATRIX_JSON="$MATRIX_JSON]}"
          echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT

          if [[ $COUNT -gt 0 ]]; then
            echo "has-submodules=true" >> $GITHUB_OUTPUT
          else
            echo "has-submodules=false" >> $GITHUB_OUTPUT
          fi

          echo "Found $COUNT changed submodules"
          echo "Matrix JSON: $MATRIX_JSON"


  # Job 2: Process each submodule in parallel (PR linking, etc.)      
  link-and-validate:
    needs: discover-submodules
    if: needs.discover-submodules.outputs.has-submodules == 'true' && startsWith(github.head_ref, 'users/')

    runs-on: ubuntu-latest
    
    permissions:
      contents: write
      pull-requests: write
      issues: write
      checks: write
      statuses: write

    strategy:
      # Process up to 5 submodules in parallel (adjust as needed)
      max-parallel: 5
      matrix: ${{ fromJson(needs.discover-submodules.outputs.matrix) }}
    
    steps:
      - name: Process submodule - ${{ matrix.owner }}/${{ matrix.repo_name }}
        run: |
          echo "Processing submodule: ${{ matrix.owner }}/${{ matrix.repo_name }}"
          echo "Path: ${{ matrix.path }}"
          echo "Full repo: ${{ matrix.repo }}"
          
      # This step doesn't need to checkout the main repo again!
      # It only works with the submodule repository via API calls

      - name: Extract ticket number
        id: extract
        run: |
          BRANCH_NAME="${{ github.head_ref }}"
          TICKET_NUM=$(echo "$BRANCH_NAME" | sed 's/users\///')
          echo "ticket_num=$TICKET_NUM" >> $GITHUB_OUTPUT
          echo "Branch: $BRANCH_NAME, Ticket: $TICKET_NUM"
      
      - name: Check for submodule PR
        id: check_pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const branchName = 'users/${{ steps.extract.outputs.ticket_num }}';
            const owner = '${{ matrix.owner }}';
            const repo = '${{ matrix.repo_name }}';
            const path = '${{ matrix.path }}';
            // Search for PR with matching branch
            const { data: prs } = await github.rest.pulls.list({
              owner: owner,
              repo: repo,
              state: 'open',
              head: `${owner}:${branchName}`
            });
            
            if (prs.length === 0) {
              core.setOutput('found', 'false');
              core.setOutput('pr_url', '');
              core.setOutput('pr_number', '');
              return;
            }
            
            const pr = prs[0];
            core.setOutput('found', 'true');
            core.setOutput('pr_url', pr.html_url);
            core.setOutput('pr_number', pr.number.toString());
            core.setOutput('pr_state', pr.state);

      - name: Create Submodule PR status
        id: submodule_check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const found = '${{ steps.check_pr.outputs.found }}' === 'true';
            const prUrl = '${{ steps.check_pr.outputs.pr_url }}';
            const submoduleName = '${{ matrix.submodule }}'; // Assuming you have this in your matrix
            
            // ... your existing logic for determining status, conclusion, title, summary ...
            
            // Instead of creating the check, save the result to a file
            const result = {
              submodule: submoduleName,
              found: found,
              prUrl: prUrl,
              status: status,
              conclusion: conclusion,
              title: title,
              summary: summary,
              isApproved: found ? (conclusion === 'success') : false
            };
            
            // Save result to file for artifact upload
            fs.writeFileSync('result.json', JSON.stringify(result, null, 2));
            console.log(`Saved result for submodule: ${submoduleName}`);

      - name: Upload Submodule Result
        uses: actions/upload-artifact@v4
        with:
          name: submodule-result-${{ matrix.submodule }}
          path: result.json
          retention-days: 1 # Clean up quickly

  # Job 4: Collect results (optional)
  # Then create a dependent job that collects all results:
  collect-and-report:
    needs: [link-and-validate] # Your matrix job name
    runs-on: ubuntu-latest
    if: always() # Run even if some matrix jobs fail
    steps:
      - name: Collect Results and Create Check
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const matrixResults = ${{ toJSON(needs.link-and-validate.outputs) }};
            const results = [];
            
            // Process each matrix job result
            for (const [key, value] of Object.entries(matrixResults)) {
              if (key.startsWith('result-')) {
                try {
                  const result = JSON.parse(value);
                  results.push(result);
                } catch (e) {
                  console.log(`Failed to parse result for ${key}:`, e);
                }
              }
            }
            
            // Determine overall status
            const hasFailures = results.some(r => r.conclusion === 'failure');
            const hasInProgress = results.some(r => r.status === 'in_progress');
            const allApproved = results.every(r => r.isApproved || r.conclusion === 'success');
            
            let overallStatus, overallConclusion, overallTitle, overallSummary;
            
            if (hasFailures) {
              overallStatus = 'completed';
              overallConclusion = 'failure';
              overallTitle = 'Submodule PR Issues Found';
            } else if (hasInProgress) {
              overallStatus = 'in_progress';
              overallTitle = 'Submodule PRs Awaiting Approval';
            } else {
              overallStatus = 'completed';
              overallConclusion = 'success';
              overallTitle = 'All Submodule PRs Ready';
            }
            
            // Build summary
            let summaryLines = [`## Submodule PR Status Report\n`];
            
            results.forEach(result => {
              const icon = result.conclusion === 'success' ? '✅' : 
                          result.conclusion === 'failure' ? '❌' : 
                          result.status === 'in_progress' ? '⏳' : '⚪';
              
              summaryLines.push(`${icon} **${result.submodule}**: ${result.title}`);
              if (result.prUrl) {
                summaryLines.push(`   - PR: ${result.prUrl}`);
              }
              if (result.summary) {
                summaryLines.push(`   - ${result.summary.split('\n')[0]}`);
              }
              summaryLines.push('');
            });
            
            overallSummary = summaryLines.join('\n');
            
            // Create the consolidated check
            await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'Submodule PR Status',
              head_sha: context.sha,
              status: overallStatus,
              conclusion: overallConclusion,
              output: {
                title: overallTitle,
                summary: overallSummary
              }
            });
            
            // Optional: Also create a PR comment
            if (context.payload.pull_request) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: overallSummary
              });
            }
      
      # - name: Add PR label
      #   uses: actions/github-script@v7
      #   with:
      #     github-token: ${{ secrets.GITHUB_TOKEN }}
      #     script: |
      #       const found = '${{ steps.check_pr.outputs.found }}' === 'true';
      #       const label = found ? 'submodule-linked' : 'submodule-pending';
      #       const isApproved = '${{ steps.antman.outputs.is_approved }}' === 'true';
      #       console.log(`Label: ${label}, Submodule PR Status: ${isApproved}`);
            
      #       await github.rest.issues.addLabels({
      #         owner: context.repo.owner,
      #         repo: context.repo.repo,
      #         issue_number: context.issue.number,
      #         labels: [label]
      #       });

      #       // Update labels
      #       if(isApproved) {
      #         await github.rest.issues.addLabels({
      #           owner: context.repo.owner,
      #           repo: context.repo.repo,
      #           issue_number: context.issue.number,
      #           labels: ['ready-to-merge']
      #         });  
      #       };

  #Job 3: Check Submodule Pointers
  check-submodule-pointers:
    runs-on: ubuntu-latest
    name: Validate Submodule Pointers
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: false  # Don't initialize submodules yet
        fetch-depth: 0     # Get full history
        
    - name: Check submodule pointers
      id: check-pointers
      run: |
        #!/bin/bash
        set -e
        
        echo "Checking submodule pointers..."
        
        # Get list of submodules
        if [ ! -f .gitmodules ]; then
          echo "No .gitmodules file found - no submodules to check"
          exit 0
        fi
        
        # Parse .gitmodules to get submodule info
        submodules=$(git config --file .gitmodules --get-regexp path | awk '{print $2}')
        
        if [ -z "$submodules" ]; then
          echo "No submodules found in .gitmodules"
          exit 0
        fi
        
        exit_code=0
        
        for submodule_path in $submodules; do
          echo "Checking submodule: $submodule_path"
          
          # Get the submodule URL and current commit SHA
          submodule_url=$(git config --file .gitmodules --get submodule.$submodule_path.url)
          current_sha=$(git ls-tree HEAD $submodule_path | awk '{print $3}')
          
          if [ -z "$current_sha" ]; then
            echo "❌ Could not find SHA for submodule $submodule_path"
            exit_code=1
            continue
          fi
          
          echo "  Current SHA: $current_sha"
          echo "  URL: $submodule_url"
          
          # Clone the submodule repository to a temp directory
          temp_dir=$(mktemp -d)
          echo "  Cloning submodule to check branches..."
          
          if ! git clone "$submodule_url" "$temp_dir" --quiet; then
            echo "❌ Failed to clone submodule repository: $submodule_url"
            exit_code=1
            continue
          fi
          
          cd "$temp_dir"
          
          # Fetch all branches
          git fetch origin --quiet
          
          # Check if the SHA exists on main branch
          if git merge-base --is-ancestor "$current_sha" origin/main 2>/dev/null; then
            echo "✅ SHA $current_sha is reachable from main branch"
          else
            echo "❌ SHA $current_sha is NOT reachable from main branch"
            echo "  This commit may be on a feature branch only"
            
            # Show which branches contain this commit for debugging
            branches_with_commit=$(git branch -r --contains "$current_sha" 2>/dev/null | grep -v "HEAD" | sed 's/origin\///' | tr '\n' ' ' || echo "none")
            echo "  Branches containing this commit: $branches_with_commit"
            
            exit_code=1
          fi
          
          # Cleanup
          cd - > /dev/null
          rm -rf "$temp_dir"
          echo ""
        done
        
        if [ $exit_code -eq 0 ]; then
          echo "🎉 All submodule pointers are valid (pointing to commits on main branch)"
        else
          echo "💥 One or more submodule pointers are invalid"
          echo ""
          echo "To fix this issue:"
          echo "1. Update the submodule to point to a commit that exists on the main branch"
          echo "2. Or merge the feature branch containing the commit into main first"
          echo ""
          echo "Commands to update submodule:"
          echo "  cd <submodule-path>"
          echo "  git checkout main"
          echo "  git pull origin main"
          echo "  cd .."
          echo "  git add <submodule-path>"
          echo "  git commit -m 'Update submodule to latest main'"
        fi
        
        exit $exit_code
        
    - name: Report status
      if: always()
      run: |
        if [ ${{ steps.check-pointers.outcome }} == 'success' ]; then
          echo "✅ Submodule pointer check: PASSED"
        else
          echo "❌ Submodule pointer check: FAILED"
        fi