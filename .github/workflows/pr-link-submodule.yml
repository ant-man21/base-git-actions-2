# .github/workflows/pr-link-submodule.yml
name: Link PR

on:
  pull_request:
    types: [opened, synchronize]
    branches:
      - main
      - master
      - develop  # Add your target branches here

jobs:
  # Job 1: Checkout once and discover all submodules
  discover-submodules:
    name: Discover Submodules
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.submodule.outputs.matrix }}
      has-submodules: ${{ steps.submodule.outputs.has-submodules }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Only checkout the main repo, not submodules yet
          submodules: true #maybe false idk
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get changed submodules
        id: submodule
        run: |
          # set -x  
          # Figure out the base ref (for PRs, use the PR base; otherwise fallback to main)
          if [[ -n "${{ github.event.pull_request.base.sha }}" ]]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
          else
            BASE_SHA="origin/main"
          fi
          echo "# üîç Discover Submodules" >> $GITHUB_STEP_SUMMARY
          echo "### Comparing against base: $BASE_SHA"
          # Get list of actual submodules from .gitmodules
          ACTUAL_SUBMODULES=$(git config --file .gitmodules --get-regexp "submodule\..*\.path" | awk '{print $2}' || true)
          
          if [[ -z "$ACTUAL_SUBMODULES" ]]; then
            echo "No submodules found in .gitmodules"
            echo "has-submodules=false" >> $GITHUB_OUTPUT
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get all changed files
          ALL_CHANGED_FILES=$(git diff --name-only $BASE_SHA HEAD || true)
          
          # Filter to only include actual submodules that have changes
          CHANGED_SUBMODULES=""
          for submodule_path in $ACTUAL_SUBMODULES; do
            if echo "$ALL_CHANGED_FILES" | grep -q "^$submodule_path$"; then
              CHANGED_SUBMODULES="$CHANGED_SUBMODULES $submodule_path"
            fi
          done

          if [[ -z "$CHANGED_SUBMODULES" ]]; then
            echo "### ‚úÖ No submodule changes detected" >> $GITHUB_STEP_SUMMARY
            echo "has-submodules=false" >> $GITHUB_OUTPUT
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            exit 0
          fi

          MATRIX_JSON="{\"include\":["
          FIRST=true
          COUNT=0

          for SUBMODULE_PATH in $CHANGED_SUBMODULES; do
            echo "---" >> $GITHUB_STEP_SUMMARY
            echo "### üìÇ Processing changed submodule: $SUBMODULE_PATH" >> $GITHUB_STEP_SUMMARY

            # Extract name from .gitmodules
            submodule_name=$(git config --file .gitmodules --get-regexp "submodule\..*\.path" | \
                            awk -v p="$SUBMODULE_PATH" '$2==p {print $1}' | sed 's/submodule\.//; s/\.path//')

            SUBMODULE_URL=$(git config --file .gitmodules --get "submodule.$submodule_name.url")

            if [[ -z "$SUBMODULE_URL" ]]; then
              echo "  Skipping $SUBMODULE_PATH (no URL)"
              continue
            fi

            if [[ $SUBMODULE_URL == git@github.com:* ]]; then
              SUBMODULE_REPO=$(echo $SUBMODULE_URL | sed 's/git@github.com://' | sed 's/.git$//')
            elif [[ $SUBMODULE_URL == https://github.com/* ]]; then
              SUBMODULE_REPO=$(echo $SUBMODULE_URL | sed 's/https:\/\/github.com\///' | sed 's/.git$//')
            else
              echo "  Skipping non-GitHub submodule: $SUBMODULE_URL"
              continue
            fi

            IFS='/' read -r owner repo <<< "$SUBMODULE_REPO"

            if [[ $FIRST == true ]]; then
              FIRST=false
            else
              MATRIX_JSON="$MATRIX_JSON,"
            fi

            MATRIX_JSON="$MATRIX_JSON{\"path\":\"$SUBMODULE_PATH\",\"repo\":\"$SUBMODULE_REPO\",\"owner\":\"$owner\",\"repo_name\":\"$repo\",\"name\":\"$submodule_name\"}"
            COUNT=$((COUNT + 1))
          done

          MATRIX_JSON="$MATRIX_JSON]}"
          echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT

          if [[ $COUNT -gt 0 ]]; then
            echo "has-submodules=true" >> $GITHUB_OUTPUT
          else
            echo "has-submodules=false" >> $GITHUB_OUTPUT
          fi
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "### Found $COUNT changed submodules" >> $GITHUB_STEP_SUMMARY
          echo "Matrix JSON: $MATRIX_JSON"

  # Job 2: Process each submodule in parallel (PR linking, etc.)      
  link-and-validate:
    name: "PR Status: ${{ matrix.repo_name }}"
    needs: discover-submodules
    if: needs.discover-submodules.outputs.has-submodules == 'true' && startsWith(github.head_ref, 'users/')

    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      checks: write
      statuses: write

    strategy:
      # Process up to 5 submodules in parallel (adjust as needed)
      fail-fast: false
      max-parallel: 5
      matrix: ${{ fromJson(needs.discover-submodules.outputs.matrix) }}
    
    steps:
      - name: Process submodule - ${{ matrix.owner }}/${{ matrix.repo_name }}
        run: |
          echo "Processing submodule: ${{ matrix.owner }}/${{ matrix.repo_name }}"
          echo "Path: ${{ matrix.path }}"
          echo "Full repo: ${{ matrix.repo }}"

      - name: Extract ticket number
        id: extract
        run: |
          BRANCH_NAME="${{ github.head_ref }}"
          TICKET_NUM=$(echo "$BRANCH_NAME" | sed 's/users\///')
          echo "ticket_num=$TICKET_NUM" >> $GITHUB_OUTPUT
          echo "Branch: $BRANCH_NAME, Ticket: $TICKET_NUM"
      
      - name: Check for submodule PR
        id: check_pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const branchName = 'users/${{ steps.extract.outputs.ticket_num }}';
            const owner = '${{ matrix.owner }}';
            const repo = '${{ matrix.repo_name }}';
            const path = '${{ matrix.path }}';
            // Search for PR with matching branch
            const { data: prs } = await github.rest.pulls.list({
              owner: owner,
              repo: repo,
              state: 'open',
              head: `${owner}:${branchName}`
            });
            
            if (prs.length === 0) {
              core.setOutput('found', 'false');
              core.setOutput('pr_url', '');
              core.setOutput('pr_number', '');
              return;
            }
            
            const pr = prs[0];
            core.setOutput('found', 'true');
            core.setOutput('pr_url', pr.html_url);
            core.setOutput('pr_number', pr.number.toString());
            core.setOutput('pr_state', pr.state);

      - name: Create check run for submodule PR status
        id: antman
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const found = '${{ steps.check_pr.outputs.found }}' === 'true';
            const prUrl = '${{ steps.check_pr.outputs.pr_url }}';
            const submodulePrUrl = '${{ steps.check_pr.outputs.pr_url }}';
            core.setOutput('is_approved', 'false');
            core.setOutput('is_mergeable','false')
            
            // Check if submodules were updated in this PR
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            // Get list of submodules from .gitmodules to check against
            let submodulePaths = [];
            try {
              const { data: gitmodules } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: '.gitmodules',
                ref: context.payload.pull_request.base.sha
              });
              
              const content = Buffer.from(gitmodules.content, 'base64').toString();
              const pathMatches = content.match(/path = (.+)/g);
              if (pathMatches) {
                submodulePaths = pathMatches.map(match => match.replace('path = ', '').trim());
              }
            } catch (error) {
              console.log('No .gitmodules found or error reading it:', error.message);
            }
            
            const submodule_updated = files.some(file => {
              // Check if .gitmodules itself was modified
              if (file.filename === '.gitmodules') {
                return true;
              }
              
              // Check if any known submodule paths were modified
              return submodulePaths.some(submodulePath => {
                return file.filename === submodulePath || file.filename.startsWith(submodulePath + '/');
              });
            });
            
            console.log(`Submodule updated: ${submodule_updated}`);

            let status, conclusion, title, summary;
            
            if (!found) {
              // search to see if submodule was updated to begin with
              if (submodule_updated) {
                status = 'completed';
                conclusion = 'failure';
                title = 'Submodule PR Not Found';
                summary = `Submodule was updated but no open PR found in submodule repository for branch users/${{ steps.extract.outputs.ticket_num }}`;
                console.error("‚ùå Failed");
                process.exit(1);
              } else {
                // No submodule updated, skip this check entirely
                status = 'completed';
                conclusion = 'success';
                title = 'Submodule Check Skipped';
                //summary = `No submodules were updated in this PR, skipping submodule PR check. Submodule updated: ${submodule_updated}`;
                //console.error("‚úÖ Skipping submodule");
                process.exit(0);
              }
            } else {
              // PR found - now check if it's open and approved
              
              // Extract PR number and repo info from the PR URL
              // Assuming prUrl format: https://github.com/owner/repo/pull/123
              const urlParts = prUrl.match(/github\.com\/([^\/]+)\/([^\/]+)\/pull\/(\d+)/);
              if (!urlParts) {
                status = 'completed';
                conclusion = 'failure';
                title = 'Invalid PR URL';
                summary = `Could not parse submodule PR URL: ${prUrl}`;
              } else {
                const [, submoduleOwner, submoduleRepo, prNumber] = urlParts;
                
                try {
                  // Get PR details
                  const { data: pr } = await github.rest.pulls.get({
                    owner: submoduleOwner,
                    repo: submoduleRepo,
                    pull_number: parseInt(prNumber)
                  });
                                    
                  // Check if PR is open
                  if (pr.state !== 'open') {
                    status = 'completed';
                    conclusion = 'failure';
                    title = 'Submodule PR Closed';
                    summary = `Linked submodule PR is ${pr.state}: ${prUrl}`;
                  } else {
                    // PR is open, now check approval status
                    const { data: reviews } = await github.rest.pulls.listReviews({
                      owner: submoduleOwner,
                      repo: submoduleRepo,
                      pull_number: parseInt(prNumber)
                    });
                    
                    // Get latest review from each reviewer
                    const latestReviews = {};
                    reviews.forEach(review => {
                      if (review.state !== 'COMMENTED') { // Only consider APPROVED, CHANGES_REQUESTED, DISMISSED
                        latestReviews[review.user.login] = review;
                      }
                    });
                    
                    // Check if there are any approvals and no blocking change requests
                    const approvals = Object.values(latestReviews).filter(review => review.state === 'APPROVED');
                    const changeRequests = Object.values(latestReviews).filter(review => review.state === 'CHANGES_REQUESTED');
                    
                    console.log(`Approvals: ${approvals.length}, Change Requests: ${changeRequests.length}`);
                    
                    // Check if PR is ready to merge
                    const isApproved = approvals.length > 0 && changeRequests.length === 0;
                    // push to outputs
                    core.setOutput('approvals_count', approvals.length);
                    core.setOutput('change_requests_count', changeRequests.length);
                    if (isApproved) {
                      core.setOutput('is_approved', 'true');
                      core.setOutput('is_mergeable','true');
                      status = 'completed';
                      conclusion = 'success';
                      title = 'Submodule PR Approved';
                      summary = `Submodule PR is open and approved: ${prUrl}\n\nApprovals: ${approvals.length}\nReady for coordinated merge.`;
                    } else {
                      status = 'in_progress';
                      conclusion = undefined;
                      title = 'Submodule PR Awaiting Approval';
                      summary = `Linked to submodule PR: ${prUrl}\n\nStatus: Open but not yet approved\nApprovals: ${approvals.length}\nChange Requests: ${changeRequests.length}\n\nWaiting for approval before allowing merge.`;
                    }
                  }
                } catch (error) {
                  console.error('Error checking PR status:', error);
                  status = 'completed';
                  conclusion = 'failure';
                  title = 'Error Checking Submodule PR';
                  summary = `Failed to check status of submodule PR: ${prUrl}\nError: ${error.message}`;
                }
              }
            }
      
      - name: Add PR label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const found = '${{ steps.check_pr.outputs.found }}' === 'true';
            const label = found ? 'submodule-linked' : 'submodule-pending';
            const isApproved = '${{ steps.antman.outputs.is_approved }}' === 'true';
            console.log(`Label: ${label}, Submodule PR Status: ${isApproved}`);
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: [label]
            });

            // Update labels
            if(isApproved) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['ready-to-merge']
              });  
            };

      - name: Add comment with submodule PR link
        if: steps.check_pr.outputs.found == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.issue.number;
            const submodulePrUrl = '${{ steps.check_pr.outputs.pr_url }}';
            const submoduleRepo = '${{ matrix.repo_name }}';
            const isApproved = '${{ steps.antman.outputs.is_approved }}' === 'true';
            console.log(`Submodule PR Status: ${isApproved}`);
            let approval_comment;
            if (isApproved) {
              approval_comment = "‚úÖ submodule PR approved!";
            } else {
              approval_comment = "‚è≥ Waiting for submodule PR to be approved";
            }
            const comment = `üîó Linked Submodule PR: [\`${submoduleRepo}\`](${submodulePrUrl})\nStatus = ${approval_comment}`;
            
            // Check if we already commented
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });
            console.log("number of comments: " + comments.length);
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes(`üîó Linked Submodule PR: [\`${submoduleRepo}\`]`)
            );
            
            if (botComment) {
              console.log('Comment already exists');
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              console.log('Comment does not exist');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: comment
              });
            }
      - name: Summarize & Validate PR Status
        run: |
          # Raw outputs
          mergeable="${{ steps.check_pr.outputs.is_mergeable }}"
          pr_state="${{ steps.check_pr.outputs.found }}"
          is_approved="${{ steps.antman.outputs.is_approved }}"
          approvals_count="${{ steps.antman.outputs.approvals_count }}"
          change_requests_count="${{ steps.antman.outputs.change_requests_count }}"

          # Map mergeable -> emoji + text
          if [[ "$mergeable" == "true" ]]; then
            mergeable_display="üü¢ Mergeable"
          else
            mergeable_display="‚õî Blocked"
          fi

          # Map PR state -> emoji + text
          if [[ "$pr_state" == "true" ]]; then
            pr_state_display="üìÇ Open"
          else
            pr_state_display="‚ùì Not Found"
          fi

          # Map approval -> emoji + text
          if [[ "$is_approved" == "true" ]]; then
            approval_display="‚úÖ Approved"
          else
            approval_display="‚ö†Ô∏è Pending ($approvals_count/2)"
          fi

          # Write summary
          echo "## üìã PR Status Report" >> $GITHUB_STEP_SUMMARY
          echo "- **PR:** \`${{ matrix.repo }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Path:** \`${{ matrix.path }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Ticket:** \`${{ steps.extract.outputs.ticket_num }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîç Status" >> $GITHUB_STEP_SUMMARY
          echo "- **PR State:** $pr_state_display" >> $GITHUB_STEP_SUMMARY
          echo "- **Mergeable State:** $mergeable_display" >> $GITHUB_STEP_SUMMARY
          echo "- **Approvals:** $approval_display" >> $GITHUB_STEP_SUMMARY
          echo "- **Change Requests:** \`$change_requests_count\`" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY

          # Final result + exit code
          if [[ "$pr_state" == "true" && "$is_approved" == "true" && "$mergeable" == "true" ]]; then
            echo "## üéâ Result" >> $GITHUB_STEP_SUMMARY
            echo "The PR check **succeeded**. The Submodule PR is mergeable and approved." >> $GITHUB_STEP_SUMMARY
            exit 0
          else
            echo "## ‚ùå Result" >> $GITHUB_STEP_SUMMARY
            echo "The PR check **failed**. One or more conditions are not satisfied." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

  workflow-status:
    name: "Link PR"
    runs-on: ubuntu-latest  
    needs: [discover-submodules, link-and-validate]
    if: always()  # Always run this job
    steps:
      - name: Check results
        run: |
          if [[ "${{ needs.discover-submodules.outputs.has-submodules }}" == "false" ]]; then
            echo "## No submodules found - check passes ‚úÖ" >> $GITHUB_STEP_SUMMARY
            exit 0
          elif [[ "${{ needs.link-and-validate.result }}" == "success" ]]; then
            echo "## All submodule checks passed ‚úÖ" >> $GITHUB_STEP_SUMMARY
            exit 0
          else
            echo "## Required submodules check failed ‚ùå" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

  #Job 3: Check Submodule Pointers
  check-submodule-pointers:
    runs-on: ubuntu-latest
    name: Validate Submodule Pointers
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: false  # Don't initialize submodules yet
        fetch-depth: 0     # Get full history
        
    - name: Check submodule pointers
      id: check-pointers
      run: |
        #!/bin/bash
        set -e
        
        echo "Checking submodule pointers..."
        
        # Get list of submodules
        if [ ! -f .gitmodules ]; then
          echo "No .gitmodules file found - no submodules to check"
          exit 0
        fi
        
        # Parse .gitmodules to get submodule info
        submodules=$(git config --file .gitmodules --get-regexp path | awk '{print $2}')
        
        if [ -z "$submodules" ]; then
          echo "No submodules found in .gitmodules"
          exit 0
        fi
        
        exit_code=0
        echo "# üîç Submodule Pointer Validation" >> $GITHUB_STEP_SUMMARY
        echo "## Submodule Checks" >> $GITHUB_STEP_SUMMARY
        for submodule_path in $submodules; do
          echo "### üìÇ $submodule_path" >> $GITHUB_STEP_SUMMARY
          
          # Get the submodule URL and current commit SHA
          submodule_url=$(git config --file .gitmodules --get submodule.$submodule_path.url)
          current_sha=$(git ls-tree HEAD $submodule_path | awk '{print $3}')
          
          if [ -z "$current_sha" ]; then
            echo "‚ùå Could not find SHA for submodule $submodule_path"
            exit_code=1
            continue
          fi
          
          echo "- **Current SHA:** \`$current_sha\`" >> $GITHUB_STEP_SUMMARY
          echo "- **URL:** $submodule_url" >> $GITHUB_STEP_SUMMARY
          
          # Clone the submodule repository to a temp directory
          temp_dir=$(mktemp -d)
          echo "  Cloning submodule to check branches..."
          
          if ! git clone "$submodule_url" "$temp_dir" --quiet; then
            echo "‚ùå Failed to clone submodule repository: $submodule_url" 
            exit_code=1
            continue
          fi
          
          cd "$temp_dir"
          
          # Fetch all branches
          git fetch origin --quiet
          
          # Check if the SHA exists on main branch
          if git merge-base --is-ancestor "$current_sha" origin/main 2>/dev/null; then
            echo "- **Status:** ‚úÖ SHA is reachable from **main** branch" >> $GITHUB_STEP_SUMMARY
            echo "---" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Status:** ‚ùå SHA is NOT reachable from **main** branch. This commit may be on a feature branch only." >> $GITHUB_STEP_SUMMARY
            echo "---" >> $GITHUB_STEP_SUMMARY
            
            # Show which branches contain this commit for debugging
            # branches_with_commit=$(git branch -r --contains "$current_sha" 2>/dev/null | grep -v "HEAD" | sed 's/origin\///' | tr '\n' ' ' || echo "none")
            # echo "  Branches containing this commit: $branches_with_commit"
            
            exit_code=1
          fi
          
          # Cleanup
          cd - > /dev/null
          rm -rf "$temp_dir"
          echo ""
        done
        
        if [ $exit_code -eq 0 ]; then
          echo "## üéâ Result" >> $GITHUB_STEP_SUMMARY
          echo "**All submodule pointers are valid (pointing to commits on \`main\` branch)**" >> $GITHUB_STEP_SUMMARY
        else
          echo "## ‚ùå Result" >> $GITHUB_STEP_SUMMARY
          echo "üí• One or more submodule pointers are invalid" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "To fix this issue:" >> $GITHUB_STEP_SUMMARY
          echo "1. Update the submodule to point to a commit that exists on the main branch" >> $GITHUB_STEP_SUMMARY
          echo "2. Or merge the feature branch containing the commit into main first" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Commands to update submodule:" >> $GITHUB_STEP_SUMMARY
          echo "  cd <submodule-path>" >> $GITHUB_STEP_SUMMARY
          echo "  git checkout main" >> $GITHUB_STEP_SUMMARY
          echo "  git pull origin main" >> $GITHUB_STEP_SUMMARY
          echo "  cd .." >> $GITHUB_STEP_SUMMARY
          echo "  git add <submodule-path>" >> $GITHUB_STEP_SUMMARY
          echo "  git commit -m 'Update submodule to latest main'" >> $GITHUB_STEP_SUMMARY
        fi
        exit $exit_code
        
    - name: Report status
      if: always()
      run: |
        if [ ${{ steps.check-pointers.outcome }} == 'success' ]; then
          echo "### ‚úÖ Submodule pointer check: PASSED"
        else
          echo "### ‚ùå Submodule pointer check: FAILED"
        fi